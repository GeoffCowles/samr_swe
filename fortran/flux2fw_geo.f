c
c
c     =====================================================
cgwc      subroutine flux2(ixy,maxm,meqn,maux,mbc,mx,
      subroutine flux2(ixy,maxm,meqn,maux,mbc,mx,mwaves,mthlim,
     &                 dtdx,q1d,aux,
     &                 faddm,faddp,gaddm,gaddp,
     &                 fwave,s,
     &                 amdq,apdq,cqxx,bmasdq,bpasdq,
     &                 flux_order, transverse_prop)
cgwc   ,rpn2,rpt2)
c     =====================================================
c
c     # clawpack routine ...  modified for AMRCLAW
c
c     ixy - direction (x=1,y=2)
c     maxm = max(mx,my), max # of internal cells in either dir
c     meqn = 3
c     maux = 1 (source term)
c     mbc  = ? (number of ghost cell layers)
c     mx   = # of internal cells in i-direction
c     mwaves = 3
c     mthlim = limiter on each wave (generally = 4,4,4)
c
c--------------------------------------------------------------------
c     # flux2fw is a modified version of flux2 to use fwave instead of wave.
c     # A modified Riemann solver rp2n must be used in conjunction with this
c     # routine, which returns fwave's instead of wave's.
c     # See http://amath.washington.edu/~claw/fwave.html
c
c     # Limiters are applied to the fwave's, and the only significant
c     # modification of this code is in the "do 119" loop, for the
c     # second order corrections.
c
c--------------------------------------------------------------------
c
c
c     # Compute the modification to fluxes f and g that are generated by
c     # all interfaces along a 1D slice of the 2D grid. 
c     #    ixy = 1  if it is a slice in x
c     #          2  if it is a slice in y
c     # This value is passed into the Riemann solvers. The flux modifications
c     # go into the arrays fadd and gadd.  The notation is written assuming
c     # we are solving along a 1D slice in the x-direction.
c
c     # fadd(i,.) modifies F to the left of cell i
c     # gadd(i,.,1) modifies G below cell i
c     # gadd(i,.,2) modifies G above cell i
c
c     # The method used is specified by method(2:3):
c
c         method(2) = 1 if only first order increment waves are to be used.
c                   = 2 if second order correction terms are to be added, with
c                       a flux limiter as specified by mthlim.  
c
c         method(3) = 0 if no transverse propagation is to be applied.
c                       Increment and perhaps correction waves are propagated
c                       normal to the interface.
c                   = 1 if transverse propagation of increment waves 
c                       (but not correction waves, if any) is to be applied.
c                   = 2 if transverse propagation of correction waves is also
c                       to be included.  
c
c     Note that if mcapa>0 then the capa array comes into the second 
c     order correction terms, and is already included in dtdx1d:
c     If ixy = 1 then
c        dtdx1d(i) = dt/dx                      if mcapa= 0
c                  = dt/(dx*aux(i,jcom,mcapa))  if mcapa = 1
c     If ixy = 2 then
c        dtdx1d(j) = dt/dy                      if mcapa = 0
c                  = dt/(dy*aux(icom,j,mcapa))  if mcapa = 1
c
c     Notation:
c        The jump in q (q1d(i,:)-q1d(i-1,:))  is split by rpn2 into
c            amdq =  the left-going flux difference  A^- Delta q  
c            apdq = the right-going flux difference  A^+ Delta q  
c        Each of these is split by rpt2 into 
c            bmasdq = the down-going transverse flux difference B^- A^* Delta q
c            bpasdq =   the up-going transverse flux difference B^+ A^* Delta q
c        where A^* represents either A^- or A^+.
c

c--------------------------flux2fw_drylimiting.f--------------------------
c     This version of flux2fw.f is modified slightly to be used with 
c     step2_drylimiting.  The only modification is for the first-order
c     mass fluxes, faddm(i,j,1) and faddp(i,j,1), so that those terms are true
c     interface fluxes.
c     
c     The only change is in loop 40 
c---------------------last modified 1/04/05-----------------------------

cgwc      implicit double precision (a-h,o-z)
      implicit none
cwgc      include "call.i"

cgwc      external rpn2, rpt2
C       dimension  q1d(1-mbc:maxm+mbc, meqn)
C       dimension  amdq(1-mbc:maxm+mbc, meqn)
C       dimension  apdq(1-mbc:maxm+mbc, meqn)
C       dimension  bmasdq(1-mbc:maxm+mbc, meqn)
C       dimension  bpasdq(1-mbc:maxm+mbc, meqn)
C       dimension  cqxx(1-mbc:maxm+mbc, meqn)
C       dimension  faddm(1-mbc:maxm+mbc, meqn)
C       dimension  faddp(1-mbc:maxm+mbc, meqn)
C       dimension  gaddm(1-mbc:maxm+mbc, meqn, 2)
C       dimension  gaddp(1-mbc:maxm+mbc, meqn, 2)
C       dimension  dtdx1d(1-mbc:maxm+mbc)
C       dimension  aux1(1-mbc:maxm+mbc, maux)
C       dimension  aux2(1-mbc:maxm+mbc, maux)
C       dimension  aux3(1-mbc:maxm+mbc, maux)
C c
C       dimension  s(1-mbc:maxm+mbc, mwaves)
C       dimension  fwave(1-mbc:maxm+mbc, meqn, mwaves)
c   
      integer ixy,maxm,meqn,maux,mbc,mx,mwaves
      integer mthlim(mwaves)
cgwc      double precision  cfl1d
      double precision  dtdx
      double precision  q1d(1-mbc:maxm+mbc, meqn)
      double precision  amdq(1-mbc:maxm+mbc, meqn)
      double precision  apdq(1-mbc:maxm+mbc, meqn)
      double precision  bmasdq(1-mbc:maxm+mbc, meqn)
      double precision  bpasdq(1-mbc:maxm+mbc, meqn)
      double precision  cqxx(1-mbc:maxm+mbc, meqn)
      double precision  faddm(1-mbc:maxm+mbc, meqn)
      double precision  faddp(1-mbc:maxm+mbc, meqn)
      double precision  gaddm(1-mbc:maxm+mbc, meqn, 2)
      double precision  gaddp(1-mbc:maxm+mbc, meqn, 2)
cgwc      double precision  dtdx1d(1-mbc:maxm+mbc)
      double precision  aux(1-mbc:maxm+mbc, maux)
cgwc      double precision  aux2(1-mbc:maxm+mbc, maux)
cgwc      double precision  aux3(1-mbc:maxm+mbc, maux)
      double precision  s(1-mbc:maxm+mbc, mwaves)
      double precision  fwave(1-mbc:maxm+mbc, meqn, mwaves)
      integer :: flux_order
      integer :: transverse_prop

      integer i,jside,m,mw,mu
      double precision dxdc,gupdate
c
      logical limit
cgwc      common /comxyt/ dtcom,dxcom,dycom,tcom,icom,jcom

cgwc      include "geo.i"

cgwc  set global parameters

c
      limit = .false.
      do 5 mw=1,mwaves
         if (mthlim(mw) .gt. 0) limit = .true.
   5     continue
c
c     # initialize flux increments:
c     -----------------------------
c
      do 30 jside=1,2
         do 20 m=1,meqn
            do 10 i = 1-mbc, mx+mbc
               faddm(i,m) = 0.d0
               faddp(i,m) = 0.d0
               gaddm(i,m,jside) = 0.d0
               gaddp(i,m,jside) = 0.d0
   10          continue
   20       continue
   30    continue
c
c
c     # solve Riemann problem at each interface and compute Godunov updates
c     ---------------------------------------------------------------------
c
C       write(*,*)'h==',q1d(:,1)
C       write(*,*)'uh==',q1d(:,2)
C       write(*,*)'vh==',q1d(:,3)
      call rpn2(ixy,maxm,meqn,mwaves,mbc,mx,q1d,q1d,
     &          aux,aux,fwave,s,amdq,apdq)
c
c   # Set fadd for the donor-cell upwind method (Godunov)
      if (ixy.eq.1) mu=2
      if (ixy.eq.2) mu=3
      dxdc=1.d0
      do 40 i=1-mbc+1,mx+mbc-1
C       	   if (mcapa.gt.0) then
C       	    if (ixy.eq.1) dxdc=Rearth*pi/180.d0
C 	    if (ixy.eq.2) dxdc=aux2(i,3)
C 	   else
C	   endif
            faddp(i,1) = faddp(i,1) + dxdc*q1d(i,mu) - apdq(i,1)
            faddm(i,1) = faddp(i,1)
         do 40 m=2,meqn
            faddp(i,m) = faddp(i,m) - apdq(i,m)
            faddm(i,m) = faddm(i,m) + amdq(i,m)
   40       continue

       
CGWC - debug 1st order, no transverse correction first
C c     # compute maximum wave speed for checking Courant number:
C       cfl1d = 0.d0
C       do 50 mw=1,mwaves
C          do 50 i=1,mx+1
C c          # if s>0 use dtdx1d(i) to compute CFL,
C c          # if s<0 use dtdx1d(i-1) to compute CFL:
C             cfl1d = dmax1(cfl1d, dtdx1d(i)*s(i,mw),
C      &                          -dtdx1d(i-1)*s(i,mw))
C 
C    50       continue
C c
C       if (method(2).eq.1) go to 130
C c
c     # modify F fluxes for second order q_{xx} correction terms:
c     -----------------------------------------------------------
c
c     # apply limiter to fwaves:
      if(flux_order .eq. 1) go to 130
      if (limit) call limiter(maxm,meqn,mwaves,mbc,mx,fwave,s,mthlim)
c
      do 120 i = 1, mx+1
c
c        # For correction terms below, need average of dtdx in cell
c        # i-1 and i.  Compute these and overwrite dtdx1d:
c
cgwc         dtdx1d(i-1) = 0.5d0 * (dtdx1d(i-1) + dtdx1d(i))
c
         do 120 m=1,meqn
            cqxx(i,m) = 0.d0
            do 119 mw=1,mwaves
c
c              # second order corrections:
               cqxx(i,m) = cqxx(i,m) + dsign(1.d0,s(i,mw))
     &            * (1.d0 - dabs(s(i,mw))*dtdx) * fwave(i,m,mw)
c     &            * (1.d0 - dabs(s(i,mw))*dtdx1d(i-1)) * fwave(i,m,mw)
c
  119          continue
            faddm(i,m) = faddm(i,m) + 0.5d0 * cqxx(i,m)
            faddp(i,m) = faddp(i,m) + 0.5d0 * cqxx(i,m)
  120       continue
c
C c
  130  continue

C c
C        if (method(3).eq.0) go to 999   !# no transverse propagation
        if (transverse_prop.eq.0) go to 999   !# no transverse propagation
c
        if (transverse_prop.eq.2) then
c         # incorporate cqxx into amdq and apdq so that it is split also.
          do 150 i = 1, mx+1
             do 150 m=1,meqn
                amdq(i,m) = amdq(i,m) + cqxx(i,m)
                apdq(i,m) = apdq(i,m) - cqxx(i,m)
  150           continue
          endif
c
c
c      # modify G fluxes for transverse propagation
c      --------------------------------------------
c
c
c     # split the left-going flux difference into down-going and up-going:
C       call rpt2(ixy,maxm,meqn,mwaves,mbc,mx,
C      &          q1d,q1d,aux1,aux2,aux3,
C      &          1,amdq,bmasdq,bpasdq)
      call rpt2(ixy,maxm,meqn,mwaves,mbc,mx,
     &          q1d,q1d,1,amdq,bmasdq,bpasdq)
c
c     # modify flux below and above by B^- A^- Delta q and  B^+ A^- Delta q:
      do 160 m=1,meqn
          do 160 i = 1, mx+1
               gupdate = 0.5d0*dtdx * bmasdq(i,m)
cgwc               gupdate = 0.5d0*dtdx1d(i-1) * bmasdq(i,m)
               gaddm(i-1,m,1) = gaddm(i-1,m,1) - gupdate
               gaddp(i-1,m,1) = gaddp(i-1,m,1) - gupdate
c
               gupdate = 0.5d0*dtdx * bpasdq(i,m)
cgwc           gupdate = 0.5d0*dtdx1d(i-1) * bpasdq(i,m)
               gaddm(i-1,m,2) = gaddm(i-1,m,2) - gupdate
               gaddp(i-1,m,2) = gaddp(i-1,m,2) - gupdate
  160          continue
c
c     # split the right-going flux difference into down-going and up-going:
C       call rpt2(ixy,maxm,meqn,mwaves,mbc,mx,
C      &          q1d,q1d,aux1,aux2,aux3,
C      &          2,apdq,bmasdq,bpasdq)

      call rpt2(ixy,maxm,meqn,mwaves,mbc,mx,
     &          q1d,q1d,2,apdq,bmasdq,bpasdq)
c
c     # modify flux below and above by B^- A^+ Delta q and  B^+ A^+ Delta q:
      do 180 m=1,meqn
          do 180 i = 1, mx+1
c               gupdate = 0.5d0*dtdx1d(i-1) * bmasdq(i,m)
               gupdate = 0.5d0*dtdx * bmasdq(i,m)
               gaddm(i,m,1) = gaddm(i,m,1) - gupdate
               gaddp(i,m,1) = gaddp(i,m,1) - gupdate
c
c               gupdate = 0.5d0*dtdx1d(i-1) * bpasdq(i,m)
               gupdate = 0.5d0*dtdx * bpasdq(i,m)
               gaddm(i,m,2) = gaddm(i,m,2) - gupdate
               gaddp(i,m,2) = gaddp(i,m,2) - gupdate
  180          continue
c
  999 continue
      return
      end
